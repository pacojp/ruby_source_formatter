require File.expand_path(__dir__) + '/test_helper'

class TestRsf < Test::Unit::TestCase

  def setup
    @klass = Class.new do
      extend RubySourceFormatter
    end
  end

  def assert_format(should_be, from)
    assert_equal should_be, @klass.format(from)
  end

  def test_all
    # テストケースと from とshould_beの順に
    # 並べて書いています(横棒区切り)
    #
    # 参考
    # http://bojovs.github.com/2012/04/24/ruby-coding-style/
    #
    test= <<EOF
a=>:a,b=>b,:c=>'c'
========================================
a  => :a,
b  => b,
:c => 'c'
========================================
{a=>:a,b=>b,:c=>'c'}
========================================
{
  a  => :a,
  b  => b,
  :c => 'c'
}
========================================
  a=>:a, # comment
  b=>b,  :c=>'c'
========================================
  a  => :a, # comment
  b  => b,
  :c => 'c'
========================================
  aaa:a, # comment
    bb:123,:c=>"c"
========================================
  aaa: a, # comment
  bb:  123,
  :c   => "c"
========================================
{
    a:a, # comment
    bb:123,:ccc=>'c'}
========================================
{
  a:   a, # comment
  bb:  123,
  :ccc => 'c'
}
========================================
  {
    a:a, # comment
    bb:123,:ccc=>'c'}
========================================
  {
    a:   a, # comment
    bb:  123,
    :ccc => 'c'
  }
========================================
  test = {
a:a, # comment
bb:123,:ccc=>'c'}
========================================
  test = {
    a:   a, # comment
    bb:  123,
    :ccc => 'c'
  }
========================================
  test = {
      a:a, # comment
bb:123,ccc:'c'}
========================================
  test = {
    a:   a, # comment
    bb:  123,
    ccc: 'c'
  }
========================================
  test = {
    # comment
      a:a, # comment
bb:123,ccc:'c'}
========================================
  test = {
    # comment
    a:   a, # comment
    bb:  123,
    ccc: 'c'
  }
========================================
  aaa = 'aaa'
========================================
  aaa = 'aaa'
========================================
  # comment
  aaa = 'aaa' # comment
    # comment 2
  b = 'bbbb'
  'ccc' * 10
========================================
  # comment
  aaa   = 'aaa' # comment
  # comment 2
  b     = 'bbbb'
  'ccc' * 10
========================================
  def test(a,b,c)
========================================
  def test(a, b, c)
========================================
  def test(a,b,c={})
========================================
  def test(a, b, c = {})
========================================
  test(a,b,c)
========================================
  test(a, b, c)
========================================
  def test(a,b=nil,c=1)
========================================
  def test(a, b = nil, c = 1)
========================================
  a=[1,2,""],b=nil,c=1
========================================
  a = [1, 2, ""],
  b = nil,
  c = 1
========================================
def some_method(arg1=:default,arg2=nil,arg3=[])
end
========================================
def some_method(arg1 = :default, arg2 = nil, arg3 = [])
end
========================================
  a = [1,2,3,4]
========================================
  a = [1, 2, 3, 4]
========================================
  # comment1
  def test(a,b=nil,c=[1,:test,nil])
  # comment2
  hash={1=>a,22=>b,
  # comment3  
3=>[1,2,3]}
  end
========================================
  # comment1
  def test(a, b = nil, c = [1, :test, nil])
    # comment2
    hash = {
      1  => a,
      22 => b,
      # comment3
      3  => [1, 2, 3]
    }
  end
========================================
    # comment1
    def test(a,b=nil,c=[1,:test,nil])
    # comment2
    hash={1=>a,22=>b,
    # comment3  
    3=>[1,2,3]}
  end
========================================
    # comment1
    def test(a, b = nil, c = [1, :test, nil])
      # comment2
      hash = {
        1  => a,
        22 => b,
        # comment3
        3  => [1, 2, 3]
      }
    end
========================================
  @aa ||= 0
  @bbb = 0 if @indent < 0
  @cccc  ||= 0
========================================
  @aa   ||= 0
  @bbb  = 0 if @indent < 0
  @cccc ||= 0
========================================
  if ar == [1,2]
    a = [1,2,3,4]
  end
========================================
  if ar == [1, 2]
    a = [1, 2, 3, 4]
  end
========================================
  if ar == [1,2]
    a = false
  else
    a = [1,2,3,4]
  end
========================================
  if ar == [1, 2]
    a = false
  else
    a = [1, 2, 3, 4]
  end
========================================
  unless ar == [1,2]
  a = [1,2,3,4]
  end
========================================
  unless ar == [1, 2]
    a = [1, 2, 3, 4]
  end
========================================
sum = 1+2
========================================
sum = 1 + 2
========================================
e = M * c ** 2
========================================
e = M * c**2
========================================
1>2 ? true : false ;puts 'Hi'
========================================
1 > 2 ? true : false; puts 'Hi'
========================================
  debug "init_line"
  @line = [indent]
========================================
  debug "init_line"
  @line = [indent]
========================================
  hash.each do |_,v|
    result = v.map { |k, v|v + 1}
  end
========================================
  hash.each do |_, v|
    result = v.map { |k, v| v + 1 }
  end
========================================
names.select {|name|name.start_with?("S")}.map{|name|name.upcase}
========================================
names.select { |name| name.start_with?("S") }.map { |name| name.upcase }
========================================
# TODO このテストケースから再開
# 列揃えだけど、複数回数の概念が必要になる、、、、
  a={}
  bbb={"1"=>1}
  cc = {one:1,two:2 }

  dddddd = {}
========================================
  a   = {}
  bbb = { "1" => 1 }
  cc  = { one: 1, two: 2 }

  dddddd = {}
EOF
    test.split(/========================================\n/m).each_slice(2) do |from,should_be|
      assert_format should_be.chomp, from.chomp
    end
  end
end
